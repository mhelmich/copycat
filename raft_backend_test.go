/*
 * Copyright 2018 Marco Helmich
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package copycat

import (
	"context"
	"os"
	"strconv"
	"sync"
	"testing"
	"time"

	"github.com/coreos/etcd/raft"
	"github.com/coreos/etcd/raft/raftpb"
	"github.com/mhelmich/copycat/pb"
	log "github.com/sirupsen/logrus"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
)

func TestRaftBackendBasic(t *testing.T) {
	fakeTransport := newFakeTransport()

	config1 := DefaultConfig()
	config1.CopyCatDataDir = "./test-TestRaftBackendBasic-" + uint64ToString(randomRaftId()) + "/"
	err := os.MkdirAll(config1.CopyCatDataDir, os.ModePerm)
	assert.Nil(t, err)
	config1.CopyCatPort = config1.CopyCatPort + 22222
	config1.raftTransport = fakeTransport
	config1.logger = log.WithFields(log.Fields{
		"raft1": "raft1",
	})
	detachedBackend1, err := newDetachedRaftBackendWithId(randomRaftId(), config1)
	assert.Nil(t, err)
	fakeTransport.add(detachedBackend1)
	assert.NotNil(t, detachedBackend1)

	config2 := DefaultConfig()
	config2.CopyCatDataDir = "./test-TestRaftBackendBasic-" + uint64ToString(randomRaftId()) + "/"
	err = os.MkdirAll(config2.CopyCatDataDir, os.ModePerm)
	assert.Nil(t, err)
	config2.CopyCatPort = config1.CopyCatPort + 1111
	config2.raftTransport = fakeTransport
	config2.logger = log.WithFields(log.Fields{
		"raft2": "raft2",
	})
	detachedBackend2, err := newDetachedRaftBackendWithId(randomRaftId(), config2)
	assert.Nil(t, err)
	fakeTransport.add(detachedBackend2)
	assert.NotNil(t, detachedBackend2)

	config3 := DefaultConfig()
	config3.CopyCatDataDir = "./test-TestRaftBackendBasic-" + uint64ToString(randomRaftId()) + "/"
	err = os.MkdirAll(config3.CopyCatDataDir, os.ModePerm)
	assert.Nil(t, err)
	config3.CopyCatPort = config2.CopyCatPort + 1111
	config3.raftTransport = fakeTransport
	config3.logger = log.WithFields(log.Fields{
		"raft3": "raft3",
	})
	peers3 := make([]pb.Peer, 2)
	peers3[0] = pb.Peer{
		Id:          detachedBackend1.raftId,
		RaftAddress: config1.hostname + ":" + strconv.Itoa(config1.CopyCatPort),
	}
	peers3[1] = pb.Peer{
		Id:          detachedBackend2.raftId,
		RaftAddress: config2.hostname + ":" + strconv.Itoa(config2.CopyCatPort),
	}
	interactiveBackend, err := newInteractiveRaftBackend(config3, peers3, func() ([]byte, error) { return make([]byte, 0), nil })
	assert.Nil(t, err)
	fakeTransport.add(interactiveBackend)
	assert.NotNil(t, interactiveBackend)
	time.Sleep(1 * time.Second)
	consumeAndPrintEvents(interactiveBackend)
	assert.NotNil(t, interactiveBackend.raftNode)

	interactiveBackend.proposeChan <- []byte("hello")
	interactiveBackend.proposeChan <- []byte("world")

	// not waiting for anything in particular
	time.Sleep(1 * time.Second)

	detachedBackend1.stop()
	detachedBackend2.stop()
	interactiveBackend.stop()

	err = os.RemoveAll(config1.CopyCatDataDir)
	assert.Nil(t, err)
	err = os.RemoveAll(config2.CopyCatDataDir)
	assert.Nil(t, err)
	err = os.RemoveAll(config3.CopyCatDataDir)
	assert.Nil(t, err)
}

// TODO
func TestTriggerSnapshot(t *testing.T) {

}

func consumeAndPrintEvents(rb *raftBackend) {
	if rb.isInteractive {
		go func() {
			for {
				select {
				case c, ok := <-rb.commitChan:
					if !ok {
						return
					}
					log.Debugf("Committed %v", c)
				case e, ok := <-rb.errorChan:
					if !ok {
						return
					}
					log.Debugf("Error %v", e)
				}
			}
		}()
	}
}

func newFakeTransport() *fakeTransport {
	return &fakeTransport{
		backends: &sync.Map{},
	}
}

type fakeTransport struct {
	backends *sync.Map
}

func (ft *fakeTransport) add(rb *raftBackend) {
	ft.backends.Store(rb.raftId, rb)
}

func (ft *fakeTransport) sendMessages(msgs []raftpb.Message) {
	for _, msg := range msgs {
		val, ok := ft.backends.Load(msg.To)
		rb := val.(*raftBackend)
		if !ok {
			log.Panicf("You didn't set the test correctly! Backend with id %d doesn't exist!", msg.To)
		}

		err := rb.step(context.TODO(), msg)
		if err != nil {
			log.Errorf("Error stepping in raft %d: %s", msg.To, err.Error())
		}
	}
}

// Thank you mockery!
// MockRaftNode is an autogenerated mock type for the MockRaftNode type
type MockRaftNode struct {
	mock.Mock
}

// Advance provides a mock function with given fields:
func (_m *MockRaftNode) Advance() {
	_m.Called()
}

// ApplyConfChange provides a mock function with given fields: cc
func (_m *MockRaftNode) ApplyConfChange(cc raftpb.ConfChange) *raftpb.ConfState {
	ret := _m.Called(cc)

	var r0 *raftpb.ConfState
	if rf, ok := ret.Get(0).(func(raftpb.ConfChange) *raftpb.ConfState); ok {
		r0 = rf(cc)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*raftpb.ConfState)
		}
	}

	return r0
}

// Campaign provides a mock function with given fields: ctx
func (_m *MockRaftNode) Campaign(ctx context.Context) error {
	ret := _m.Called(ctx)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Propose provides a mock function with given fields: ctx, data
func (_m *MockRaftNode) Propose(ctx context.Context, data []byte) error {
	ret := _m.Called(ctx, data)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []byte) error); ok {
		r0 = rf(ctx, data)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ProposeConfChange provides a mock function with given fields: ctx, cc
func (_m *MockRaftNode) ProposeConfChange(ctx context.Context, cc raftpb.ConfChange) error {
	ret := _m.Called(ctx, cc)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, raftpb.ConfChange) error); ok {
		r0 = rf(ctx, cc)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ReadIndex provides a mock function with given fields: ctx, rctx
func (_m *MockRaftNode) ReadIndex(ctx context.Context, rctx []byte) error {
	ret := _m.Called(ctx, rctx)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []byte) error); ok {
		r0 = rf(ctx, rctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Ready provides a mock function with given fields:
func (_m *MockRaftNode) Ready() <-chan raft.Ready {
	ret := _m.Called()

	var r0 <-chan raft.Ready
	if rf, ok := ret.Get(0).(func() <-chan raft.Ready); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan raft.Ready)
		}
	}

	return r0
}

// ReportSnapshot provides a mock function with given fields: id, status
func (_m *MockRaftNode) ReportSnapshot(id uint64, status raft.SnapshotStatus) {
	_m.Called(id, status)
}

// ReportUnreachable provides a mock function with given fields: id
func (_m *MockRaftNode) ReportUnreachable(id uint64) {
	_m.Called(id)
}

// Status provides a mock function with given fields:
func (_m *MockRaftNode) Status() raft.Status {
	ret := _m.Called()

	var r0 raft.Status
	if rf, ok := ret.Get(0).(func() raft.Status); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(raft.Status)
	}

	return r0
}

// Step provides a mock function with given fields: ctx, msg
func (_m *MockRaftNode) Step(ctx context.Context, msg raftpb.Message) error {
	ret := _m.Called(ctx, msg)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, raftpb.Message) error); ok {
		r0 = rf(ctx, msg)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Stop provides a mock function with given fields:
func (_m *MockRaftNode) Stop() {
	_m.Called()
}

// Tick provides a mock function with given fields:
func (_m *MockRaftNode) Tick() {
	_m.Called()
}

// TransferLeadership provides a mock function with given fields: ctx, lead, transferee
func (_m *MockRaftNode) TransferLeadership(ctx context.Context, lead uint64, transferee uint64) {
	_m.Called(ctx, lead, transferee)
}
