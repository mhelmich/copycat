// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pb/copycat.proto

/*
	Package pb is a generated protocol buffer package.

	It is generated from these files:
		pb/copycat.proto

	It has these top-level messages:
		TestCat
		Id128
		RaftIdQueryRequest
		RaftIdQueryResponse
		DataStructureIdRequest
		DataStructureIdResponse
		RaftPeer
		HostedItems
		StepReq
		StepResp
		StartRaftRequest
		StartRaftResponse
		StopRaftRequest
		StopRaftResponse
		AddRaftRequest
		AddRaftResponse
*/
package pb

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import raftpb "github.com/coreos/etcd/raft/raftpb"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type GossipQueryNames int32

const (
	RaftIdQuery          GossipQueryNames = 0
	DataStructureIdQuery GossipQueryNames = 1
)

var GossipQueryNames_name = map[int32]string{
	0: "RaftIdQuery",
	1: "DataStructureIdQuery",
}
var GossipQueryNames_value = map[string]int32{
	"RaftIdQuery":          0,
	"DataStructureIdQuery": 1,
}

func (x GossipQueryNames) String() string {
	return proto.EnumName(GossipQueryNames_name, int32(x))
}
func (GossipQueryNames) EnumDescriptor() ([]byte, []int) { return fileDescriptorCopycat, []int{0} }

type TestCat struct {
	M map[string]string `protobuf:"bytes,1,rep,name=m" json:"m,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *TestCat) Reset()                    { *m = TestCat{} }
func (m *TestCat) String() string            { return proto.CompactTextString(m) }
func (*TestCat) ProtoMessage()               {}
func (*TestCat) Descriptor() ([]byte, []int) { return fileDescriptorCopycat, []int{0} }

type Id128 struct {
	Upper uint64 `protobuf:"varint,1,opt,name=Upper,proto3" json:"Upper,omitempty"`
	Lower uint64 `protobuf:"varint,2,opt,name=Lower,proto3" json:"Lower,omitempty"`
}

func (m *Id128) Reset()                    { *m = Id128{} }
func (m *Id128) String() string            { return proto.CompactTextString(m) }
func (*Id128) ProtoMessage()               {}
func (*Id128) Descriptor() ([]byte, []int) { return fileDescriptorCopycat, []int{1} }

type RaftIdQueryRequest struct {
	RaftId uint64 `protobuf:"varint,1,opt,name=RaftId,proto3" json:"RaftId,omitempty"`
}

func (m *RaftIdQueryRequest) Reset()                    { *m = RaftIdQueryRequest{} }
func (m *RaftIdQueryRequest) String() string            { return proto.CompactTextString(m) }
func (*RaftIdQueryRequest) ProtoMessage()               {}
func (*RaftIdQueryRequest) Descriptor() ([]byte, []int) { return fileDescriptorCopycat, []int{2} }

type RaftIdQueryResponse struct {
	Peer *RaftPeer `protobuf:"bytes,1,opt,name=peer" json:"peer,omitempty"`
}

func (m *RaftIdQueryResponse) Reset()                    { *m = RaftIdQueryResponse{} }
func (m *RaftIdQueryResponse) String() string            { return proto.CompactTextString(m) }
func (*RaftIdQueryResponse) ProtoMessage()               {}
func (*RaftIdQueryResponse) Descriptor() ([]byte, []int) { return fileDescriptorCopycat, []int{3} }

type DataStructureIdRequest struct {
	DataStructureId *Id128 `protobuf:"bytes,1,opt,name=DataStructureId" json:"DataStructureId,omitempty"`
}

func (m *DataStructureIdRequest) Reset()                    { *m = DataStructureIdRequest{} }
func (m *DataStructureIdRequest) String() string            { return proto.CompactTextString(m) }
func (*DataStructureIdRequest) ProtoMessage()               {}
func (*DataStructureIdRequest) Descriptor() ([]byte, []int) { return fileDescriptorCopycat, []int{4} }

type DataStructureIdResponse struct {
	Peers []*RaftPeer `protobuf:"bytes,1,rep,name=peers" json:"peers,omitempty"`
}

func (m *DataStructureIdResponse) Reset()                    { *m = DataStructureIdResponse{} }
func (m *DataStructureIdResponse) String() string            { return proto.CompactTextString(m) }
func (*DataStructureIdResponse) ProtoMessage()               {}
func (*DataStructureIdResponse) Descriptor() ([]byte, []int) { return fileDescriptorCopycat, []int{5} }

type RaftPeer struct {
	RaftId      uint64 `protobuf:"varint,1,opt,name=RaftId,proto3" json:"RaftId,omitempty"`
	PeerAddress string `protobuf:"bytes,2,opt,name=PeerAddress,proto3" json:"PeerAddress,omitempty"`
}

func (m *RaftPeer) Reset()                    { *m = RaftPeer{} }
func (m *RaftPeer) String() string            { return proto.CompactTextString(m) }
func (*RaftPeer) ProtoMessage()               {}
func (*RaftPeer) Descriptor() ([]byte, []int) { return fileDescriptorCopycat, []int{6} }

type HostedItems struct {
	DataStructureToRaftMapping map[string]uint64 `protobuf:"bytes,1,rep,name=DataStructureToRaftMapping" json:"DataStructureToRaftMapping,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *HostedItems) Reset()                    { *m = HostedItems{} }
func (m *HostedItems) String() string            { return proto.CompactTextString(m) }
func (*HostedItems) ProtoMessage()               {}
func (*HostedItems) Descriptor() ([]byte, []int) { return fileDescriptorCopycat, []int{7} }

type StepReq struct {
	Message *raftpb.Message `protobuf:"bytes,1,opt,name=Message" json:"Message,omitempty"`
}

func (m *StepReq) Reset()                    { *m = StepReq{} }
func (m *StepReq) String() string            { return proto.CompactTextString(m) }
func (*StepReq) ProtoMessage()               {}
func (*StepReq) Descriptor() ([]byte, []int) { return fileDescriptorCopycat, []int{8} }

type StepResp struct {
	Error string `protobuf:"bytes,1,opt,name=Error,proto3" json:"Error,omitempty"`
}

func (m *StepResp) Reset()                    { *m = StepResp{} }
func (m *StepResp) String() string            { return proto.CompactTextString(m) }
func (*StepResp) ProtoMessage()               {}
func (*StepResp) Descriptor() ([]byte, []int) { return fileDescriptorCopycat, []int{9} }

type StartRaftRequest struct {
	DataStructureId *Id128      `protobuf:"bytes,1,opt,name=DataStructureId" json:"DataStructureId,omitempty"`
	RaftIdToUse     uint64      `protobuf:"varint,2,opt,name=RaftIdToUse,proto3" json:"RaftIdToUse,omitempty"`
	AllRaftPeers    []*RaftPeer `protobuf:"bytes,3,rep,name=AllRaftPeers" json:"AllRaftPeers,omitempty"`
}

func (m *StartRaftRequest) Reset()                    { *m = StartRaftRequest{} }
func (m *StartRaftRequest) String() string            { return proto.CompactTextString(m) }
func (*StartRaftRequest) ProtoMessage()               {}
func (*StartRaftRequest) Descriptor() ([]byte, []int) { return fileDescriptorCopycat, []int{10} }

type StartRaftResponse struct {
	RaftId      uint64 `protobuf:"varint,1,opt,name=RaftId,proto3" json:"RaftId,omitempty"`
	RaftAddress string `protobuf:"bytes,2,opt,name=RaftAddress,proto3" json:"RaftAddress,omitempty"`
}

func (m *StartRaftResponse) Reset()                    { *m = StartRaftResponse{} }
func (m *StartRaftResponse) String() string            { return proto.CompactTextString(m) }
func (*StartRaftResponse) ProtoMessage()               {}
func (*StartRaftResponse) Descriptor() ([]byte, []int) { return fileDescriptorCopycat, []int{11} }

type StopRaftRequest struct {
	RaftId uint64 `protobuf:"varint,1,opt,name=RaftId,proto3" json:"RaftId,omitempty"`
}

func (m *StopRaftRequest) Reset()                    { *m = StopRaftRequest{} }
func (m *StopRaftRequest) String() string            { return proto.CompactTextString(m) }
func (*StopRaftRequest) ProtoMessage()               {}
func (*StopRaftRequest) Descriptor() ([]byte, []int) { return fileDescriptorCopycat, []int{12} }

type StopRaftResponse struct {
}

func (m *StopRaftResponse) Reset()                    { *m = StopRaftResponse{} }
func (m *StopRaftResponse) String() string            { return proto.CompactTextString(m) }
func (*StopRaftResponse) ProtoMessage()               {}
func (*StopRaftResponse) Descriptor() ([]byte, []int) { return fileDescriptorCopycat, []int{13} }

type AddRaftRequest struct {
	NewRaftId      uint64 `protobuf:"varint,1,opt,name=NewRaftId,proto3" json:"NewRaftId,omitempty"`
	ExistingRaftId uint64 `protobuf:"varint,2,opt,name=ExistingRaftId,proto3" json:"ExistingRaftId,omitempty"`
}

func (m *AddRaftRequest) Reset()                    { *m = AddRaftRequest{} }
func (m *AddRaftRequest) String() string            { return proto.CompactTextString(m) }
func (*AddRaftRequest) ProtoMessage()               {}
func (*AddRaftRequest) Descriptor() ([]byte, []int) { return fileDescriptorCopycat, []int{14} }

type AddRaftResponse struct {
}

func (m *AddRaftResponse) Reset()                    { *m = AddRaftResponse{} }
func (m *AddRaftResponse) String() string            { return proto.CompactTextString(m) }
func (*AddRaftResponse) ProtoMessage()               {}
func (*AddRaftResponse) Descriptor() ([]byte, []int) { return fileDescriptorCopycat, []int{15} }

func init() {
	proto.RegisterType((*TestCat)(nil), "pb.TestCat")
	proto.RegisterType((*Id128)(nil), "pb.Id128")
	proto.RegisterType((*RaftIdQueryRequest)(nil), "pb.RaftIdQueryRequest")
	proto.RegisterType((*RaftIdQueryResponse)(nil), "pb.RaftIdQueryResponse")
	proto.RegisterType((*DataStructureIdRequest)(nil), "pb.DataStructureIdRequest")
	proto.RegisterType((*DataStructureIdResponse)(nil), "pb.DataStructureIdResponse")
	proto.RegisterType((*RaftPeer)(nil), "pb.RaftPeer")
	proto.RegisterType((*HostedItems)(nil), "pb.HostedItems")
	proto.RegisterType((*StepReq)(nil), "pb.StepReq")
	proto.RegisterType((*StepResp)(nil), "pb.StepResp")
	proto.RegisterType((*StartRaftRequest)(nil), "pb.StartRaftRequest")
	proto.RegisterType((*StartRaftResponse)(nil), "pb.StartRaftResponse")
	proto.RegisterType((*StopRaftRequest)(nil), "pb.StopRaftRequest")
	proto.RegisterType((*StopRaftResponse)(nil), "pb.StopRaftResponse")
	proto.RegisterType((*AddRaftRequest)(nil), "pb.AddRaftRequest")
	proto.RegisterType((*AddRaftResponse)(nil), "pb.AddRaftResponse")
	proto.RegisterEnum("pb.GossipQueryNames", GossipQueryNames_name, GossipQueryNames_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for RaftTransportService service

type RaftTransportServiceClient interface {
	Step(ctx context.Context, opts ...grpc.CallOption) (RaftTransportService_StepClient, error)
}

type raftTransportServiceClient struct {
	cc *grpc.ClientConn
}

func NewRaftTransportServiceClient(cc *grpc.ClientConn) RaftTransportServiceClient {
	return &raftTransportServiceClient{cc}
}

func (c *raftTransportServiceClient) Step(ctx context.Context, opts ...grpc.CallOption) (RaftTransportService_StepClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_RaftTransportService_serviceDesc.Streams[0], c.cc, "/pb.RaftTransportService/Step", opts...)
	if err != nil {
		return nil, err
	}
	x := &raftTransportServiceStepClient{stream}
	return x, nil
}

type RaftTransportService_StepClient interface {
	Send(*StepReq) error
	Recv() (*StepResp, error)
	grpc.ClientStream
}

type raftTransportServiceStepClient struct {
	grpc.ClientStream
}

func (x *raftTransportServiceStepClient) Send(m *StepReq) error {
	return x.ClientStream.SendMsg(m)
}

func (x *raftTransportServiceStepClient) Recv() (*StepResp, error) {
	m := new(StepResp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for RaftTransportService service

type RaftTransportServiceServer interface {
	Step(RaftTransportService_StepServer) error
}

func RegisterRaftTransportServiceServer(s *grpc.Server, srv RaftTransportServiceServer) {
	s.RegisterService(&_RaftTransportService_serviceDesc, srv)
}

func _RaftTransportService_Step_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RaftTransportServiceServer).Step(&raftTransportServiceStepServer{stream})
}

type RaftTransportService_StepServer interface {
	Send(*StepResp) error
	Recv() (*StepReq, error)
	grpc.ServerStream
}

type raftTransportServiceStepServer struct {
	grpc.ServerStream
}

func (x *raftTransportServiceStepServer) Send(m *StepResp) error {
	return x.ServerStream.SendMsg(m)
}

func (x *raftTransportServiceStepServer) Recv() (*StepReq, error) {
	m := new(StepReq)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _RaftTransportService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.RaftTransportService",
	HandlerType: (*RaftTransportServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Step",
			Handler:       _RaftTransportService_Step_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "pb/copycat.proto",
}

// Client API for CopyCatService service

type CopyCatServiceClient interface {
	StartRaft(ctx context.Context, in *StartRaftRequest, opts ...grpc.CallOption) (*StartRaftResponse, error)
	StopRaft(ctx context.Context, in *StopRaftRequest, opts ...grpc.CallOption) (*StopRaftResponse, error)
	AddRaftToRaftGroup(ctx context.Context, in *AddRaftRequest, opts ...grpc.CallOption) (*AddRaftResponse, error)
}

type copyCatServiceClient struct {
	cc *grpc.ClientConn
}

func NewCopyCatServiceClient(cc *grpc.ClientConn) CopyCatServiceClient {
	return &copyCatServiceClient{cc}
}

func (c *copyCatServiceClient) StartRaft(ctx context.Context, in *StartRaftRequest, opts ...grpc.CallOption) (*StartRaftResponse, error) {
	out := new(StartRaftResponse)
	err := grpc.Invoke(ctx, "/pb.CopyCatService/StartRaft", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *copyCatServiceClient) StopRaft(ctx context.Context, in *StopRaftRequest, opts ...grpc.CallOption) (*StopRaftResponse, error) {
	out := new(StopRaftResponse)
	err := grpc.Invoke(ctx, "/pb.CopyCatService/StopRaft", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *copyCatServiceClient) AddRaftToRaftGroup(ctx context.Context, in *AddRaftRequest, opts ...grpc.CallOption) (*AddRaftResponse, error) {
	out := new(AddRaftResponse)
	err := grpc.Invoke(ctx, "/pb.CopyCatService/AddRaftToRaftGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for CopyCatService service

type CopyCatServiceServer interface {
	StartRaft(context.Context, *StartRaftRequest) (*StartRaftResponse, error)
	StopRaft(context.Context, *StopRaftRequest) (*StopRaftResponse, error)
	AddRaftToRaftGroup(context.Context, *AddRaftRequest) (*AddRaftResponse, error)
}

func RegisterCopyCatServiceServer(s *grpc.Server, srv CopyCatServiceServer) {
	s.RegisterService(&_CopyCatService_serviceDesc, srv)
}

func _CopyCatService_StartRaft_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartRaftRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CopyCatServiceServer).StartRaft(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.CopyCatService/StartRaft",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CopyCatServiceServer).StartRaft(ctx, req.(*StartRaftRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CopyCatService_StopRaft_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopRaftRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CopyCatServiceServer).StopRaft(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.CopyCatService/StopRaft",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CopyCatServiceServer).StopRaft(ctx, req.(*StopRaftRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CopyCatService_AddRaftToRaftGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddRaftRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CopyCatServiceServer).AddRaftToRaftGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.CopyCatService/AddRaftToRaftGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CopyCatServiceServer).AddRaftToRaftGroup(ctx, req.(*AddRaftRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _CopyCatService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.CopyCatService",
	HandlerType: (*CopyCatServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StartRaft",
			Handler:    _CopyCatService_StartRaft_Handler,
		},
		{
			MethodName: "StopRaft",
			Handler:    _CopyCatService_StopRaft_Handler,
		},
		{
			MethodName: "AddRaftToRaftGroup",
			Handler:    _CopyCatService_AddRaftToRaftGroup_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pb/copycat.proto",
}

func (m *TestCat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestCat) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.M) > 0 {
		for k, _ := range m.M {
			dAtA[i] = 0xa
			i++
			v := m.M[k]
			mapSize := 1 + len(k) + sovCopycat(uint64(len(k))) + 1 + len(v) + sovCopycat(uint64(len(v)))
			i = encodeVarintCopycat(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintCopycat(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintCopycat(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *Id128) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Id128) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Upper != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCopycat(dAtA, i, uint64(m.Upper))
	}
	if m.Lower != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCopycat(dAtA, i, uint64(m.Lower))
	}
	return i, nil
}

func (m *RaftIdQueryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftIdQueryRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RaftId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCopycat(dAtA, i, uint64(m.RaftId))
	}
	return i, nil
}

func (m *RaftIdQueryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftIdQueryResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Peer != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCopycat(dAtA, i, uint64(m.Peer.Size()))
		n1, err := m.Peer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *DataStructureIdRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataStructureIdRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DataStructureId != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCopycat(dAtA, i, uint64(m.DataStructureId.Size()))
		n2, err := m.DataStructureId.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *DataStructureIdResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataStructureIdResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Peers) > 0 {
		for _, msg := range m.Peers {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCopycat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RaftPeer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftPeer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RaftId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCopycat(dAtA, i, uint64(m.RaftId))
	}
	if len(m.PeerAddress) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCopycat(dAtA, i, uint64(len(m.PeerAddress)))
		i += copy(dAtA[i:], m.PeerAddress)
	}
	return i, nil
}

func (m *HostedItems) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HostedItems) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DataStructureToRaftMapping) > 0 {
		for k, _ := range m.DataStructureToRaftMapping {
			dAtA[i] = 0xa
			i++
			v := m.DataStructureToRaftMapping[k]
			mapSize := 1 + len(k) + sovCopycat(uint64(len(k))) + 1 + sovCopycat(uint64(v))
			i = encodeVarintCopycat(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintCopycat(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x10
			i++
			i = encodeVarintCopycat(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *StepReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StepReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Message != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCopycat(dAtA, i, uint64(m.Message.Size()))
		n3, err := m.Message.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *StepResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StepResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Error) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCopycat(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	return i, nil
}

func (m *StartRaftRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StartRaftRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DataStructureId != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCopycat(dAtA, i, uint64(m.DataStructureId.Size()))
		n4, err := m.DataStructureId.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.RaftIdToUse != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCopycat(dAtA, i, uint64(m.RaftIdToUse))
	}
	if len(m.AllRaftPeers) > 0 {
		for _, msg := range m.AllRaftPeers {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintCopycat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *StartRaftResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StartRaftResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RaftId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCopycat(dAtA, i, uint64(m.RaftId))
	}
	if len(m.RaftAddress) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCopycat(dAtA, i, uint64(len(m.RaftAddress)))
		i += copy(dAtA[i:], m.RaftAddress)
	}
	return i, nil
}

func (m *StopRaftRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StopRaftRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RaftId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCopycat(dAtA, i, uint64(m.RaftId))
	}
	return i, nil
}

func (m *StopRaftResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StopRaftResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *AddRaftRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddRaftRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NewRaftId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCopycat(dAtA, i, uint64(m.NewRaftId))
	}
	if m.ExistingRaftId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCopycat(dAtA, i, uint64(m.ExistingRaftId))
	}
	return i, nil
}

func (m *AddRaftResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddRaftResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func encodeVarintCopycat(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *TestCat) Size() (n int) {
	var l int
	_ = l
	if len(m.M) > 0 {
		for k, v := range m.M {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCopycat(uint64(len(k))) + 1 + len(v) + sovCopycat(uint64(len(v)))
			n += mapEntrySize + 1 + sovCopycat(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Id128) Size() (n int) {
	var l int
	_ = l
	if m.Upper != 0 {
		n += 1 + sovCopycat(uint64(m.Upper))
	}
	if m.Lower != 0 {
		n += 1 + sovCopycat(uint64(m.Lower))
	}
	return n
}

func (m *RaftIdQueryRequest) Size() (n int) {
	var l int
	_ = l
	if m.RaftId != 0 {
		n += 1 + sovCopycat(uint64(m.RaftId))
	}
	return n
}

func (m *RaftIdQueryResponse) Size() (n int) {
	var l int
	_ = l
	if m.Peer != nil {
		l = m.Peer.Size()
		n += 1 + l + sovCopycat(uint64(l))
	}
	return n
}

func (m *DataStructureIdRequest) Size() (n int) {
	var l int
	_ = l
	if m.DataStructureId != nil {
		l = m.DataStructureId.Size()
		n += 1 + l + sovCopycat(uint64(l))
	}
	return n
}

func (m *DataStructureIdResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Peers) > 0 {
		for _, e := range m.Peers {
			l = e.Size()
			n += 1 + l + sovCopycat(uint64(l))
		}
	}
	return n
}

func (m *RaftPeer) Size() (n int) {
	var l int
	_ = l
	if m.RaftId != 0 {
		n += 1 + sovCopycat(uint64(m.RaftId))
	}
	l = len(m.PeerAddress)
	if l > 0 {
		n += 1 + l + sovCopycat(uint64(l))
	}
	return n
}

func (m *HostedItems) Size() (n int) {
	var l int
	_ = l
	if len(m.DataStructureToRaftMapping) > 0 {
		for k, v := range m.DataStructureToRaftMapping {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCopycat(uint64(len(k))) + 1 + sovCopycat(uint64(v))
			n += mapEntrySize + 1 + sovCopycat(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *StepReq) Size() (n int) {
	var l int
	_ = l
	if m.Message != nil {
		l = m.Message.Size()
		n += 1 + l + sovCopycat(uint64(l))
	}
	return n
}

func (m *StepResp) Size() (n int) {
	var l int
	_ = l
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovCopycat(uint64(l))
	}
	return n
}

func (m *StartRaftRequest) Size() (n int) {
	var l int
	_ = l
	if m.DataStructureId != nil {
		l = m.DataStructureId.Size()
		n += 1 + l + sovCopycat(uint64(l))
	}
	if m.RaftIdToUse != 0 {
		n += 1 + sovCopycat(uint64(m.RaftIdToUse))
	}
	if len(m.AllRaftPeers) > 0 {
		for _, e := range m.AllRaftPeers {
			l = e.Size()
			n += 1 + l + sovCopycat(uint64(l))
		}
	}
	return n
}

func (m *StartRaftResponse) Size() (n int) {
	var l int
	_ = l
	if m.RaftId != 0 {
		n += 1 + sovCopycat(uint64(m.RaftId))
	}
	l = len(m.RaftAddress)
	if l > 0 {
		n += 1 + l + sovCopycat(uint64(l))
	}
	return n
}

func (m *StopRaftRequest) Size() (n int) {
	var l int
	_ = l
	if m.RaftId != 0 {
		n += 1 + sovCopycat(uint64(m.RaftId))
	}
	return n
}

func (m *StopRaftResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *AddRaftRequest) Size() (n int) {
	var l int
	_ = l
	if m.NewRaftId != 0 {
		n += 1 + sovCopycat(uint64(m.NewRaftId))
	}
	if m.ExistingRaftId != 0 {
		n += 1 + sovCopycat(uint64(m.ExistingRaftId))
	}
	return n
}

func (m *AddRaftResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func sovCopycat(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCopycat(x uint64) (n int) {
	return sovCopycat(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TestCat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCopycat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestCat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestCat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field M", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopycat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCopycat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.M == nil {
				m.M = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCopycat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCopycat
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCopycat
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCopycat
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthCopycat
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCopycat(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCopycat
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.M[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCopycat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCopycat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Id128) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCopycat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Id128: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Id128: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Upper", wireType)
			}
			m.Upper = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopycat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Upper |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lower", wireType)
			}
			m.Lower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopycat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lower |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCopycat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCopycat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftIdQueryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCopycat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftIdQueryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftIdQueryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftId", wireType)
			}
			m.RaftId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopycat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RaftId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCopycat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCopycat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftIdQueryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCopycat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftIdQueryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftIdQueryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopycat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCopycat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Peer == nil {
				m.Peer = &RaftPeer{}
			}
			if err := m.Peer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCopycat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCopycat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataStructureIdRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCopycat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataStructureIdRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataStructureIdRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataStructureId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopycat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCopycat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DataStructureId == nil {
				m.DataStructureId = &Id128{}
			}
			if err := m.DataStructureId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCopycat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCopycat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataStructureIdResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCopycat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataStructureIdResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataStructureIdResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopycat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCopycat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Peers = append(m.Peers, &RaftPeer{})
			if err := m.Peers[len(m.Peers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCopycat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCopycat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftPeer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCopycat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftPeer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftPeer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftId", wireType)
			}
			m.RaftId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopycat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RaftId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopycat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCopycat
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCopycat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCopycat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HostedItems) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCopycat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HostedItems: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HostedItems: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataStructureToRaftMapping", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopycat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCopycat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DataStructureToRaftMapping == nil {
				m.DataStructureToRaftMapping = make(map[string]uint64)
			}
			var mapkey string
			var mapvalue uint64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCopycat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCopycat
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCopycat
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCopycat
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCopycat(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCopycat
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DataStructureToRaftMapping[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCopycat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCopycat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StepReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCopycat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StepReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StepReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopycat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCopycat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Message == nil {
				m.Message = &raftpb.Message{}
			}
			if err := m.Message.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCopycat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCopycat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StepResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCopycat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StepResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StepResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopycat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCopycat
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCopycat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCopycat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StartRaftRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCopycat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartRaftRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartRaftRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataStructureId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopycat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCopycat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DataStructureId == nil {
				m.DataStructureId = &Id128{}
			}
			if err := m.DataStructureId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftIdToUse", wireType)
			}
			m.RaftIdToUse = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopycat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RaftIdToUse |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllRaftPeers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopycat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCopycat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllRaftPeers = append(m.AllRaftPeers, &RaftPeer{})
			if err := m.AllRaftPeers[len(m.AllRaftPeers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCopycat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCopycat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StartRaftResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCopycat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartRaftResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartRaftResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftId", wireType)
			}
			m.RaftId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopycat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RaftId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopycat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCopycat
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RaftAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCopycat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCopycat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StopRaftRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCopycat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StopRaftRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StopRaftRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftId", wireType)
			}
			m.RaftId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopycat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RaftId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCopycat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCopycat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StopRaftResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCopycat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StopRaftResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StopRaftResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCopycat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCopycat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddRaftRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCopycat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddRaftRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddRaftRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewRaftId", wireType)
			}
			m.NewRaftId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopycat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewRaftId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExistingRaftId", wireType)
			}
			m.ExistingRaftId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopycat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExistingRaftId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCopycat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCopycat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddRaftResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCopycat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddRaftResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddRaftResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCopycat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCopycat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCopycat(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCopycat
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCopycat
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCopycat
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthCopycat
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCopycat
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCopycat(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCopycat = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCopycat   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("pb/copycat.proto", fileDescriptorCopycat) }

var fileDescriptorCopycat = []byte{
	// 718 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x54, 0xdd, 0x4e, 0x1b, 0x3d,
	0x10, 0x8d, 0x21, 0xfc, 0x64, 0x82, 0x48, 0x30, 0xf9, 0xf8, 0xa2, 0x55, 0x95, 0x46, 0xbe, 0x68,
	0xa1, 0x6a, 0x37, 0x34, 0x20, 0x81, 0x90, 0x10, 0xa2, 0x80, 0x68, 0xa4, 0x06, 0xb5, 0x9b, 0xd0,
	0xfb, 0x4d, 0xd6, 0xa4, 0x51, 0x49, 0x6c, 0x6c, 0x2f, 0x34, 0xcf, 0xd2, 0xf7, 0xa9, 0xb8, 0xa9,
	0xc4, 0x23, 0x14, 0x9e, 0xa4, 0xf2, 0xda, 0x1b, 0x76, 0xd3, 0x02, 0x17, 0xbd, 0x49, 0x3c, 0x67,
	0x66, 0xce, 0x8c, 0x67, 0x8e, 0x17, 0x8a, 0xbc, 0x53, 0xeb, 0x32, 0x3e, 0xea, 0xfa, 0xca, 0xe5,
	0x82, 0x29, 0x86, 0xa7, 0x78, 0xc7, 0x29, 0xf5, 0x58, 0x8f, 0x45, 0x66, 0x4d, 0x9f, 0x8c, 0xc7,
	0x79, 0xd3, 0xeb, 0xab, 0x2f, 0x61, 0xc7, 0xed, 0xb2, 0x41, 0xad, 0xcb, 0x04, 0x65, 0xb2, 0x46,
	0x55, 0x37, 0xa8, 0x09, 0xff, 0x4c, 0x45, 0x3f, 0xbc, 0x13, 0xfd, 0x99, 0x70, 0xe2, 0xc3, 0x5c,
	0x9b, 0x4a, 0x75, 0xe0, 0x2b, 0x5c, 0x05, 0x34, 0x28, 0xa3, 0xea, 0xf4, 0x6a, 0xbe, 0x8e, 0x5d,
	0xde, 0x71, 0x2d, 0xee, 0x36, 0x8f, 0x86, 0x4a, 0x8c, 0x3c, 0x34, 0x70, 0x36, 0x61, 0xd6, 0x18,
	0xb8, 0x08, 0xd3, 0x5f, 0xe9, 0xa8, 0x8c, 0xaa, 0x68, 0x35, 0xe7, 0xe9, 0x23, 0x2e, 0xc1, 0xcc,
	0xa5, 0x7f, 0x1e, 0xd2, 0xf2, 0x54, 0x84, 0x19, 0x63, 0x67, 0x6a, 0x1b, 0x91, 0x0d, 0x98, 0x69,
	0x04, 0x6f, 0xeb, 0xdb, 0x3a, 0xe4, 0x94, 0x73, 0x2a, 0xa2, 0xb4, 0xac, 0x67, 0x0c, 0x8d, 0x7e,
	0x60, 0x57, 0x54, 0x44, 0x89, 0x59, 0xcf, 0x18, 0xe4, 0x35, 0x60, 0xcf, 0x3f, 0x53, 0x8d, 0xe0,
	0x53, 0x48, 0xc5, 0xc8, 0xa3, 0x17, 0x21, 0x95, 0x0a, 0xaf, 0xc0, 0xac, 0x41, 0x2d, 0x85, 0xb5,
	0xc8, 0x16, 0x2c, 0xa7, 0xa2, 0x25, 0x67, 0x43, 0x49, 0x71, 0x15, 0xb2, 0x9c, 0xda, 0x7a, 0xf9,
	0xfa, 0x82, 0xbe, 0x94, 0x0e, 0xfb, 0x48, 0xa9, 0xf0, 0x22, 0x0f, 0x69, 0xc2, 0xca, 0xa1, 0xaf,
	0xfc, 0x96, 0x12, 0x61, 0x57, 0x85, 0x82, 0x36, 0x82, 0xb8, 0xd4, 0x06, 0x14, 0x26, 0x3c, 0x96,
	0x26, 0xa7, 0x69, 0xa2, 0x0b, 0x79, 0x93, 0x11, 0x64, 0x17, 0xfe, 0xff, 0x83, 0xce, 0xf6, 0x42,
	0x60, 0x46, 0x57, 0x94, 0x76, 0xc2, 0xe9, 0x66, 0x8c, 0x8b, 0x1c, 0xc2, 0x7c, 0x0c, 0x3d, 0x74,
	0x55, 0x5c, 0x85, 0xbc, 0xf6, 0xef, 0x07, 0x81, 0xa0, 0x52, 0xda, 0x69, 0x27, 0x21, 0xf2, 0x13,
	0x41, 0xfe, 0x3d, 0x93, 0x8a, 0x06, 0x0d, 0x45, 0x07, 0x12, 0x33, 0x70, 0x52, 0x4d, 0xb5, 0x99,
	0xa6, 0x6a, 0xfa, 0x9c, 0xf7, 0x87, 0x3d, 0xdb, 0x4e, 0x4d, 0xb7, 0x93, 0x48, 0x72, 0x1f, 0xce,
	0x30, 0x6a, 0x78, 0x84, 0xd2, 0x69, 0xc2, 0xf3, 0x27, 0xd2, 0x9f, 0xd2, 0x4f, 0x36, 0xa9, 0x9f,
	0x4d, 0x98, 0x6b, 0x29, 0xca, 0x3d, 0x7a, 0x81, 0xd7, 0x60, 0xae, 0x49, 0xa5, 0xf4, 0x7b, 0xd4,
	0x2e, 0xa3, 0xe0, 0x1a, 0x49, 0xbb, 0x16, 0xf6, 0x62, 0x3f, 0xa9, 0xc2, 0xbc, 0xc9, 0x92, 0x5c,
	0x73, 0x1f, 0x09, 0xc1, 0x84, 0xad, 0x67, 0x0c, 0xf2, 0x1d, 0x41, 0xb1, 0xa5, 0x7c, 0xa1, 0x74,
	0x77, 0xff, 0xb2, 0x76, 0xbd, 0x13, 0xb3, 0x9d, 0x36, 0x3b, 0x95, 0xf1, 0x0d, 0x92, 0x10, 0x5e,
	0x87, 0x85, 0xfd, 0xf3, 0xf3, 0x78, 0xb9, 0xb2, 0x3c, 0xfd, 0x17, 0x11, 0xa4, 0x22, 0x48, 0x13,
	0x96, 0x12, 0xcd, 0x59, 0x11, 0x3d, 0x22, 0x0a, 0x7d, 0x9a, 0x10, 0x45, 0x02, 0x22, 0x6b, 0x50,
	0x68, 0x29, 0xc6, 0x93, 0x57, 0x7d, 0xe8, 0x31, 0x61, 0x3d, 0x96, 0x38, 0xd4, 0x14, 0x26, 0x9f,
	0x61, 0x71, 0x3f, 0x08, 0x92, 0xd9, 0xcf, 0x20, 0x77, 0x42, 0xaf, 0x52, 0x04, 0xf7, 0x00, 0x7e,
	0x01, 0x8b, 0x47, 0xdf, 0xfa, 0x52, 0xf5, 0x87, 0x3d, 0x1b, 0x62, 0x86, 0x32, 0x81, 0x92, 0x25,
	0x28, 0x8c, 0x79, 0x4d, 0xa9, 0x57, 0xbb, 0x50, 0x3c, 0x66, 0x52, 0xf6, 0x79, 0xf4, 0x96, 0x4f,
	0xfc, 0x01, 0x95, 0xb8, 0x10, 0x0f, 0x38, 0xc2, 0x8a, 0x19, 0x5c, 0x86, 0xd2, 0xc4, 0x12, 0x8c,
	0x07, 0xd5, 0xf7, 0xa0, 0xa4, 0x43, 0xdb, 0xc2, 0x1f, 0x4a, 0xce, 0x84, 0x6a, 0x51, 0x71, 0xd9,
	0xef, 0x52, 0xfc, 0x12, 0xb2, 0x5a, 0x0f, 0x38, 0xaf, 0x67, 0x6e, 0xf5, 0xe4, 0x2c, 0xdc, 0x1b,
	0x92, 0x93, 0xcc, 0x2a, 0x5a, 0x47, 0xf5, 0x1f, 0x08, 0x16, 0x0f, 0x18, 0x1f, 0x1d, 0xf8, 0xe3,
	0xdc, 0x1d, 0xc8, 0x8d, 0x77, 0x81, 0x4b, 0x26, 0x27, 0xad, 0x1b, 0xe7, 0xbf, 0x09, 0xd4, 0xce,
	0x2d, 0x83, 0xb7, 0xb4, 0x0e, 0xcd, 0x34, 0xf1, 0xb2, 0x09, 0x4a, 0xad, 0xc1, 0x29, 0xa5, 0xc1,
	0x71, 0xe2, 0x1e, 0x60, 0x3b, 0x1a, 0xf3, 0x7e, 0x8e, 0x05, 0x0b, 0x39, 0x8e, 0xbe, 0xcc, 0xe9,
	0x55, 0x38, 0xcb, 0x29, 0x2c, 0x26, 0x78, 0x57, 0xba, 0xbe, 0xad, 0x64, 0x6e, 0x6e, 0x2b, 0x99,
	0xeb, 0xbb, 0x0a, 0xba, 0xb9, 0xab, 0xa0, 0x5f, 0x77, 0x15, 0xd4, 0x99, 0x8d, 0xbe, 0xfb, 0x1b,
	0xbf, 0x03, 0x00, 0x00, 0xff, 0xff, 0xe7, 0x1c, 0x20, 0x19, 0x54, 0x06, 0x00, 0x00,
}
