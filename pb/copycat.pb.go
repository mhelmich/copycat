// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pb/copycat.proto

/*
	Package pb is a generated protocol buffer package.

	It is generated from these files:
		pb/copycat.proto

	It has these top-level messages:
		TestCat
		RaftIdQueryRequest
		RaftIdQueryResponse
		DataStructureIdRequest
		DataStructureIdResponse
		Peer
		HostedItems
		ProposeReq
		ProposeResp
		CommitReq
		CommitResp
		ErrorReq
		ErrorResp
		ConsumeSnapshotReq
		ConsumeSnapshotResp
		ProvideSnapshotReq
		ProvideSnapshotResp
		SendReq
		SendResp
		NewDataStructureRequest
		NewDataStructureResponse
		StartRaftRequest
		StartRaftResponse
		StopRaftRequest
		StopRaftResponse
*/
package pb

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import raftpb "github.com/coreos/etcd/raft/raftpb"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type GossipQueryNames int32

const (
	RaftIdQuery          GossipQueryNames = 0
	DataStructureIdQuery GossipQueryNames = 1
)

var GossipQueryNames_name = map[int32]string{
	0: "RaftIdQuery",
	1: "DataStructureIdQuery",
}
var GossipQueryNames_value = map[string]int32{
	"RaftIdQuery":          0,
	"DataStructureIdQuery": 1,
}

func (x GossipQueryNames) String() string {
	return proto.EnumName(GossipQueryNames_name, int32(x))
}
func (GossipQueryNames) EnumDescriptor() ([]byte, []int) { return fileDescriptorCopycat, []int{0} }

type TransportError int32

const (
	NoError TransportError = 0
)

var TransportError_name = map[int32]string{
	0: "NoError",
}
var TransportError_value = map[string]int32{
	"NoError": 0,
}

func (x TransportError) String() string {
	return proto.EnumName(TransportError_name, int32(x))
}
func (TransportError) EnumDescriptor() ([]byte, []int) { return fileDescriptorCopycat, []int{1} }

type TestCat struct {
	M map[string]string `protobuf:"bytes,1,rep,name=m" json:"m,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *TestCat) Reset()                    { *m = TestCat{} }
func (m *TestCat) String() string            { return proto.CompactTextString(m) }
func (*TestCat) ProtoMessage()               {}
func (*TestCat) Descriptor() ([]byte, []int) { return fileDescriptorCopycat, []int{0} }

type RaftIdQueryRequest struct {
	RaftId uint64 `protobuf:"varint,1,opt,name=RaftId,proto3" json:"RaftId,omitempty"`
}

func (m *RaftIdQueryRequest) Reset()                    { *m = RaftIdQueryRequest{} }
func (m *RaftIdQueryRequest) String() string            { return proto.CompactTextString(m) }
func (*RaftIdQueryRequest) ProtoMessage()               {}
func (*RaftIdQueryRequest) Descriptor() ([]byte, []int) { return fileDescriptorCopycat, []int{1} }

type RaftIdQueryResponse struct {
	RaftId  uint64 `protobuf:"varint,1,opt,name=RaftId,proto3" json:"RaftId,omitempty"`
	Address string `protobuf:"bytes,2,opt,name=Address,proto3" json:"Address,omitempty"`
}

func (m *RaftIdQueryResponse) Reset()                    { *m = RaftIdQueryResponse{} }
func (m *RaftIdQueryResponse) String() string            { return proto.CompactTextString(m) }
func (*RaftIdQueryResponse) ProtoMessage()               {}
func (*RaftIdQueryResponse) Descriptor() ([]byte, []int) { return fileDescriptorCopycat, []int{2} }

type DataStructureIdRequest struct {
	DataStructureId uint64 `protobuf:"varint,1,opt,name=DataStructureId,proto3" json:"DataStructureId,omitempty"`
}

func (m *DataStructureIdRequest) Reset()                    { *m = DataStructureIdRequest{} }
func (m *DataStructureIdRequest) String() string            { return proto.CompactTextString(m) }
func (*DataStructureIdRequest) ProtoMessage()               {}
func (*DataStructureIdRequest) Descriptor() ([]byte, []int) { return fileDescriptorCopycat, []int{3} }

type DataStructureIdResponse struct {
	DataStructureId uint64 `protobuf:"varint,1,opt,name=DataStructureId,proto3" json:"DataStructureId,omitempty"`
	RaftId          uint64 `protobuf:"varint,2,opt,name=RaftId,proto3" json:"RaftId,omitempty"`
	Address         string `protobuf:"bytes,3,opt,name=Address,proto3" json:"Address,omitempty"`
}

func (m *DataStructureIdResponse) Reset()                    { *m = DataStructureIdResponse{} }
func (m *DataStructureIdResponse) String() string            { return proto.CompactTextString(m) }
func (*DataStructureIdResponse) ProtoMessage()               {}
func (*DataStructureIdResponse) Descriptor() ([]byte, []int) { return fileDescriptorCopycat, []int{4} }

type Peer struct {
	Id          uint64 `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty"`
	RaftAddress string `protobuf:"bytes,2,opt,name=RaftAddress,proto3" json:"RaftAddress,omitempty"`
}

func (m *Peer) Reset()                    { *m = Peer{} }
func (m *Peer) String() string            { return proto.CompactTextString(m) }
func (*Peer) ProtoMessage()               {}
func (*Peer) Descriptor() ([]byte, []int) { return fileDescriptorCopycat, []int{5} }

type HostedItems struct {
	DataStructureToRaftMapping map[uint64]uint64 `protobuf:"bytes,1,rep,name=DataStructureToRaftMapping" json:"DataStructureToRaftMapping,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *HostedItems) Reset()                    { *m = HostedItems{} }
func (m *HostedItems) String() string            { return proto.CompactTextString(m) }
func (*HostedItems) ProtoMessage()               {}
func (*HostedItems) Descriptor() ([]byte, []int) { return fileDescriptorCopycat, []int{6} }

type ProposeReq struct {
	DataStructureId uint64 `protobuf:"varint,1,opt,name=DataStructureId,proto3" json:"DataStructureId,omitempty"`
	Data            []byte `protobuf:"bytes,2,opt,name=Data,proto3" json:"Data,omitempty"`
}

func (m *ProposeReq) Reset()                    { *m = ProposeReq{} }
func (m *ProposeReq) String() string            { return proto.CompactTextString(m) }
func (*ProposeReq) ProtoMessage()               {}
func (*ProposeReq) Descriptor() ([]byte, []int) { return fileDescriptorCopycat, []int{7} }

type ProposeResp struct {
	ForwardAddress string `protobuf:"bytes,1,opt,name=ForwardAddress,proto3" json:"ForwardAddress,omitempty"`
}

func (m *ProposeResp) Reset()                    { *m = ProposeResp{} }
func (m *ProposeResp) String() string            { return proto.CompactTextString(m) }
func (*ProposeResp) ProtoMessage()               {}
func (*ProposeResp) Descriptor() ([]byte, []int) { return fileDescriptorCopycat, []int{8} }

type CommitReq struct {
	DataStructureId uint64 `protobuf:"varint,1,opt,name=DataStructureId,proto3" json:"DataStructureId,omitempty"`
}

func (m *CommitReq) Reset()                    { *m = CommitReq{} }
func (m *CommitReq) String() string            { return proto.CompactTextString(m) }
func (*CommitReq) ProtoMessage()               {}
func (*CommitReq) Descriptor() ([]byte, []int) { return fileDescriptorCopycat, []int{9} }

type CommitResp struct {
	Data []byte `protobuf:"bytes,1,opt,name=Data,proto3" json:"Data,omitempty"`
}

func (m *CommitResp) Reset()                    { *m = CommitResp{} }
func (m *CommitResp) String() string            { return proto.CompactTextString(m) }
func (*CommitResp) ProtoMessage()               {}
func (*CommitResp) Descriptor() ([]byte, []int) { return fileDescriptorCopycat, []int{10} }

type ErrorReq struct {
	DataStructureId uint64 `protobuf:"varint,1,opt,name=DataStructureId,proto3" json:"DataStructureId,omitempty"`
}

func (m *ErrorReq) Reset()                    { *m = ErrorReq{} }
func (m *ErrorReq) String() string            { return proto.CompactTextString(m) }
func (*ErrorReq) ProtoMessage()               {}
func (*ErrorReq) Descriptor() ([]byte, []int) { return fileDescriptorCopycat, []int{11} }

type ErrorResp struct {
	Error string `protobuf:"bytes,1,opt,name=Error,proto3" json:"Error,omitempty"`
}

func (m *ErrorResp) Reset()                    { *m = ErrorResp{} }
func (m *ErrorResp) String() string            { return proto.CompactTextString(m) }
func (*ErrorResp) ProtoMessage()               {}
func (*ErrorResp) Descriptor() ([]byte, []int) { return fileDescriptorCopycat, []int{12} }

type ConsumeSnapshotReq struct {
	DataStructureId uint64 `protobuf:"varint,1,opt,name=DataStructureId,proto3" json:"DataStructureId,omitempty"`
}

func (m *ConsumeSnapshotReq) Reset()                    { *m = ConsumeSnapshotReq{} }
func (m *ConsumeSnapshotReq) String() string            { return proto.CompactTextString(m) }
func (*ConsumeSnapshotReq) ProtoMessage()               {}
func (*ConsumeSnapshotReq) Descriptor() ([]byte, []int) { return fileDescriptorCopycat, []int{13} }

type ConsumeSnapshotResp struct {
	Data []byte `protobuf:"bytes,1,opt,name=Data,proto3" json:"Data,omitempty"`
}

func (m *ConsumeSnapshotResp) Reset()                    { *m = ConsumeSnapshotResp{} }
func (m *ConsumeSnapshotResp) String() string            { return proto.CompactTextString(m) }
func (*ConsumeSnapshotResp) ProtoMessage()               {}
func (*ConsumeSnapshotResp) Descriptor() ([]byte, []int) { return fileDescriptorCopycat, []int{14} }

type ProvideSnapshotReq struct {
	DataStructureId uint64 `protobuf:"varint,1,opt,name=DataStructureId,proto3" json:"DataStructureId,omitempty"`
	Data            []byte `protobuf:"bytes,2,opt,name=Data,proto3" json:"Data,omitempty"`
}

func (m *ProvideSnapshotReq) Reset()                    { *m = ProvideSnapshotReq{} }
func (m *ProvideSnapshotReq) String() string            { return proto.CompactTextString(m) }
func (*ProvideSnapshotReq) ProtoMessage()               {}
func (*ProvideSnapshotReq) Descriptor() ([]byte, []int) { return fileDescriptorCopycat, []int{15} }

type ProvideSnapshotResp struct {
}

func (m *ProvideSnapshotResp) Reset()                    { *m = ProvideSnapshotResp{} }
func (m *ProvideSnapshotResp) String() string            { return proto.CompactTextString(m) }
func (*ProvideSnapshotResp) ProtoMessage()               {}
func (*ProvideSnapshotResp) Descriptor() ([]byte, []int) { return fileDescriptorCopycat, []int{16} }

type SendReq struct {
	Message *raftpb.Message `protobuf:"bytes,1,opt,name=Message" json:"Message,omitempty"`
}

func (m *SendReq) Reset()                    { *m = SendReq{} }
func (m *SendReq) String() string            { return proto.CompactTextString(m) }
func (*SendReq) ProtoMessage()               {}
func (*SendReq) Descriptor() ([]byte, []int) { return fileDescriptorCopycat, []int{17} }

type SendResp struct {
	Error TransportError `protobuf:"varint,1,opt,name=Error,proto3,enum=pb.TransportError" json:"Error,omitempty"`
}

func (m *SendResp) Reset()                    { *m = SendResp{} }
func (m *SendResp) String() string            { return proto.CompactTextString(m) }
func (*SendResp) ProtoMessage()               {}
func (*SendResp) Descriptor() ([]byte, []int) { return fileDescriptorCopycat, []int{18} }

type NewDataStructureRequest struct {
}

func (m *NewDataStructureRequest) Reset()                    { *m = NewDataStructureRequest{} }
func (m *NewDataStructureRequest) String() string            { return proto.CompactTextString(m) }
func (*NewDataStructureRequest) ProtoMessage()               {}
func (*NewDataStructureRequest) Descriptor() ([]byte, []int) { return fileDescriptorCopycat, []int{19} }

type NewDataStructureResponse struct {
	DataStructureId uint64 `protobuf:"varint,1,opt,name=DataStructureId,proto3" json:"DataStructureId,omitempty"`
}

func (m *NewDataStructureResponse) Reset()                    { *m = NewDataStructureResponse{} }
func (m *NewDataStructureResponse) String() string            { return proto.CompactTextString(m) }
func (*NewDataStructureResponse) ProtoMessage()               {}
func (*NewDataStructureResponse) Descriptor() ([]byte, []int) { return fileDescriptorCopycat, []int{20} }

type StartRaftRequest struct {
}

func (m *StartRaftRequest) Reset()                    { *m = StartRaftRequest{} }
func (m *StartRaftRequest) String() string            { return proto.CompactTextString(m) }
func (*StartRaftRequest) ProtoMessage()               {}
func (*StartRaftRequest) Descriptor() ([]byte, []int) { return fileDescriptorCopycat, []int{21} }

type StartRaftResponse struct {
	RaftId      uint64 `protobuf:"varint,1,opt,name=RaftId,proto3" json:"RaftId,omitempty"`
	RaftAddress string `protobuf:"bytes,2,opt,name=RaftAddress,proto3" json:"RaftAddress,omitempty"`
}

func (m *StartRaftResponse) Reset()                    { *m = StartRaftResponse{} }
func (m *StartRaftResponse) String() string            { return proto.CompactTextString(m) }
func (*StartRaftResponse) ProtoMessage()               {}
func (*StartRaftResponse) Descriptor() ([]byte, []int) { return fileDescriptorCopycat, []int{22} }

type StopRaftRequest struct {
	RaftId uint64 `protobuf:"varint,1,opt,name=RaftId,proto3" json:"RaftId,omitempty"`
}

func (m *StopRaftRequest) Reset()                    { *m = StopRaftRequest{} }
func (m *StopRaftRequest) String() string            { return proto.CompactTextString(m) }
func (*StopRaftRequest) ProtoMessage()               {}
func (*StopRaftRequest) Descriptor() ([]byte, []int) { return fileDescriptorCopycat, []int{23} }

type StopRaftResponse struct {
}

func (m *StopRaftResponse) Reset()                    { *m = StopRaftResponse{} }
func (m *StopRaftResponse) String() string            { return proto.CompactTextString(m) }
func (*StopRaftResponse) ProtoMessage()               {}
func (*StopRaftResponse) Descriptor() ([]byte, []int) { return fileDescriptorCopycat, []int{24} }

func init() {
	proto.RegisterType((*TestCat)(nil), "pb.TestCat")
	proto.RegisterType((*RaftIdQueryRequest)(nil), "pb.RaftIdQueryRequest")
	proto.RegisterType((*RaftIdQueryResponse)(nil), "pb.RaftIdQueryResponse")
	proto.RegisterType((*DataStructureIdRequest)(nil), "pb.DataStructureIdRequest")
	proto.RegisterType((*DataStructureIdResponse)(nil), "pb.DataStructureIdResponse")
	proto.RegisterType((*Peer)(nil), "pb.Peer")
	proto.RegisterType((*HostedItems)(nil), "pb.HostedItems")
	proto.RegisterType((*ProposeReq)(nil), "pb.ProposeReq")
	proto.RegisterType((*ProposeResp)(nil), "pb.ProposeResp")
	proto.RegisterType((*CommitReq)(nil), "pb.CommitReq")
	proto.RegisterType((*CommitResp)(nil), "pb.CommitResp")
	proto.RegisterType((*ErrorReq)(nil), "pb.ErrorReq")
	proto.RegisterType((*ErrorResp)(nil), "pb.ErrorResp")
	proto.RegisterType((*ConsumeSnapshotReq)(nil), "pb.ConsumeSnapshotReq")
	proto.RegisterType((*ConsumeSnapshotResp)(nil), "pb.ConsumeSnapshotResp")
	proto.RegisterType((*ProvideSnapshotReq)(nil), "pb.ProvideSnapshotReq")
	proto.RegisterType((*ProvideSnapshotResp)(nil), "pb.ProvideSnapshotResp")
	proto.RegisterType((*SendReq)(nil), "pb.SendReq")
	proto.RegisterType((*SendResp)(nil), "pb.SendResp")
	proto.RegisterType((*NewDataStructureRequest)(nil), "pb.NewDataStructureRequest")
	proto.RegisterType((*NewDataStructureResponse)(nil), "pb.NewDataStructureResponse")
	proto.RegisterType((*StartRaftRequest)(nil), "pb.StartRaftRequest")
	proto.RegisterType((*StartRaftResponse)(nil), "pb.StartRaftResponse")
	proto.RegisterType((*StopRaftRequest)(nil), "pb.StopRaftRequest")
	proto.RegisterType((*StopRaftResponse)(nil), "pb.StopRaftResponse")
	proto.RegisterEnum("pb.GossipQueryNames", GossipQueryNames_name, GossipQueryNames_value)
	proto.RegisterEnum("pb.TransportError", TransportError_name, TransportError_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for DataStructureService service

type DataStructureServiceClient interface {
	// A client keeps sending operations into this stream.
	// CopyCat will consume this stream and try to achieve consensus.
	Propose(ctx context.Context, opts ...grpc.CallOption) (DataStructureService_ProposeClient, error)
	// All changes that CopyCat accepted and committed will be replayed via this stream.
	// This stream will contain all committed operations that have been sent to the propose stream.
	Commit(ctx context.Context, in *CommitReq, opts ...grpc.CallOption) (DataStructureService_CommitClient, error)
	// If CopyCay runs into an error when trying to commit a change, this stream will contain an error.
	Error(ctx context.Context, in *ErrorReq, opts ...grpc.CallOption) (DataStructureService_ErrorClient, error)
	// Then the commit stream hints that a new snapshot is available, this endpoint will provide it to you.
	ConsumeSnapshot(ctx context.Context, in *ConsumeSnapshotReq, opts ...grpc.CallOption) (*ConsumeSnapshotResp, error)
	// This endpoint will be used to provide a consistent snapshot of data to CopyCat.
	// In regular intervals CopyCat will ask for a consistent snapshot of your data structure.
	// Clients are required to send a request to this endpoint as soon as they start interacting
	// with a data sturcture. After they get a response from this endpoint, they need to reply
	// to the response with another message containing a snapshot of the data structure.
	// CopyCat will block until it has received the snapshot.
	ProvideSnapshot(ctx context.Context, opts ...grpc.CallOption) (DataStructureService_ProvideSnapshotClient, error)
}

type dataStructureServiceClient struct {
	cc *grpc.ClientConn
}

func NewDataStructureServiceClient(cc *grpc.ClientConn) DataStructureServiceClient {
	return &dataStructureServiceClient{cc}
}

func (c *dataStructureServiceClient) Propose(ctx context.Context, opts ...grpc.CallOption) (DataStructureService_ProposeClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_DataStructureService_serviceDesc.Streams[0], c.cc, "/pb.DataStructureService/Propose", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataStructureServiceProposeClient{stream}
	return x, nil
}

type DataStructureService_ProposeClient interface {
	Send(*ProposeReq) error
	CloseAndRecv() (*ProposeResp, error)
	grpc.ClientStream
}

type dataStructureServiceProposeClient struct {
	grpc.ClientStream
}

func (x *dataStructureServiceProposeClient) Send(m *ProposeReq) error {
	return x.ClientStream.SendMsg(m)
}

func (x *dataStructureServiceProposeClient) CloseAndRecv() (*ProposeResp, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(ProposeResp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataStructureServiceClient) Commit(ctx context.Context, in *CommitReq, opts ...grpc.CallOption) (DataStructureService_CommitClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_DataStructureService_serviceDesc.Streams[1], c.cc, "/pb.DataStructureService/Commit", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataStructureServiceCommitClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DataStructureService_CommitClient interface {
	Recv() (*CommitResp, error)
	grpc.ClientStream
}

type dataStructureServiceCommitClient struct {
	grpc.ClientStream
}

func (x *dataStructureServiceCommitClient) Recv() (*CommitResp, error) {
	m := new(CommitResp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataStructureServiceClient) Error(ctx context.Context, in *ErrorReq, opts ...grpc.CallOption) (DataStructureService_ErrorClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_DataStructureService_serviceDesc.Streams[2], c.cc, "/pb.DataStructureService/Error", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataStructureServiceErrorClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DataStructureService_ErrorClient interface {
	Recv() (*ErrorResp, error)
	grpc.ClientStream
}

type dataStructureServiceErrorClient struct {
	grpc.ClientStream
}

func (x *dataStructureServiceErrorClient) Recv() (*ErrorResp, error) {
	m := new(ErrorResp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataStructureServiceClient) ConsumeSnapshot(ctx context.Context, in *ConsumeSnapshotReq, opts ...grpc.CallOption) (*ConsumeSnapshotResp, error) {
	out := new(ConsumeSnapshotResp)
	err := grpc.Invoke(ctx, "/pb.DataStructureService/ConsumeSnapshot", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataStructureServiceClient) ProvideSnapshot(ctx context.Context, opts ...grpc.CallOption) (DataStructureService_ProvideSnapshotClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_DataStructureService_serviceDesc.Streams[3], c.cc, "/pb.DataStructureService/ProvideSnapshot", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataStructureServiceProvideSnapshotClient{stream}
	return x, nil
}

type DataStructureService_ProvideSnapshotClient interface {
	Send(*ProvideSnapshotReq) error
	Recv() (*ProvideSnapshotResp, error)
	grpc.ClientStream
}

type dataStructureServiceProvideSnapshotClient struct {
	grpc.ClientStream
}

func (x *dataStructureServiceProvideSnapshotClient) Send(m *ProvideSnapshotReq) error {
	return x.ClientStream.SendMsg(m)
}

func (x *dataStructureServiceProvideSnapshotClient) Recv() (*ProvideSnapshotResp, error) {
	m := new(ProvideSnapshotResp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for DataStructureService service

type DataStructureServiceServer interface {
	// A client keeps sending operations into this stream.
	// CopyCat will consume this stream and try to achieve consensus.
	Propose(DataStructureService_ProposeServer) error
	// All changes that CopyCat accepted and committed will be replayed via this stream.
	// This stream will contain all committed operations that have been sent to the propose stream.
	Commit(*CommitReq, DataStructureService_CommitServer) error
	// If CopyCay runs into an error when trying to commit a change, this stream will contain an error.
	Error(*ErrorReq, DataStructureService_ErrorServer) error
	// Then the commit stream hints that a new snapshot is available, this endpoint will provide it to you.
	ConsumeSnapshot(context.Context, *ConsumeSnapshotReq) (*ConsumeSnapshotResp, error)
	// This endpoint will be used to provide a consistent snapshot of data to CopyCat.
	// In regular intervals CopyCat will ask for a consistent snapshot of your data structure.
	// Clients are required to send a request to this endpoint as soon as they start interacting
	// with a data sturcture. After they get a response from this endpoint, they need to reply
	// to the response with another message containing a snapshot of the data structure.
	// CopyCat will block until it has received the snapshot.
	ProvideSnapshot(DataStructureService_ProvideSnapshotServer) error
}

func RegisterDataStructureServiceServer(s *grpc.Server, srv DataStructureServiceServer) {
	s.RegisterService(&_DataStructureService_serviceDesc, srv)
}

func _DataStructureService_Propose_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(DataStructureServiceServer).Propose(&dataStructureServiceProposeServer{stream})
}

type DataStructureService_ProposeServer interface {
	SendAndClose(*ProposeResp) error
	Recv() (*ProposeReq, error)
	grpc.ServerStream
}

type dataStructureServiceProposeServer struct {
	grpc.ServerStream
}

func (x *dataStructureServiceProposeServer) SendAndClose(m *ProposeResp) error {
	return x.ServerStream.SendMsg(m)
}

func (x *dataStructureServiceProposeServer) Recv() (*ProposeReq, error) {
	m := new(ProposeReq)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _DataStructureService_Commit_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CommitReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DataStructureServiceServer).Commit(m, &dataStructureServiceCommitServer{stream})
}

type DataStructureService_CommitServer interface {
	Send(*CommitResp) error
	grpc.ServerStream
}

type dataStructureServiceCommitServer struct {
	grpc.ServerStream
}

func (x *dataStructureServiceCommitServer) Send(m *CommitResp) error {
	return x.ServerStream.SendMsg(m)
}

func _DataStructureService_Error_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ErrorReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DataStructureServiceServer).Error(m, &dataStructureServiceErrorServer{stream})
}

type DataStructureService_ErrorServer interface {
	Send(*ErrorResp) error
	grpc.ServerStream
}

type dataStructureServiceErrorServer struct {
	grpc.ServerStream
}

func (x *dataStructureServiceErrorServer) Send(m *ErrorResp) error {
	return x.ServerStream.SendMsg(m)
}

func _DataStructureService_ConsumeSnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConsumeSnapshotReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataStructureServiceServer).ConsumeSnapshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.DataStructureService/ConsumeSnapshot",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataStructureServiceServer).ConsumeSnapshot(ctx, req.(*ConsumeSnapshotReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataStructureService_ProvideSnapshot_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(DataStructureServiceServer).ProvideSnapshot(&dataStructureServiceProvideSnapshotServer{stream})
}

type DataStructureService_ProvideSnapshotServer interface {
	Send(*ProvideSnapshotResp) error
	Recv() (*ProvideSnapshotReq, error)
	grpc.ServerStream
}

type dataStructureServiceProvideSnapshotServer struct {
	grpc.ServerStream
}

func (x *dataStructureServiceProvideSnapshotServer) Send(m *ProvideSnapshotResp) error {
	return x.ServerStream.SendMsg(m)
}

func (x *dataStructureServiceProvideSnapshotServer) Recv() (*ProvideSnapshotReq, error) {
	m := new(ProvideSnapshotReq)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _DataStructureService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.DataStructureService",
	HandlerType: (*DataStructureServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ConsumeSnapshot",
			Handler:    _DataStructureService_ConsumeSnapshot_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Propose",
			Handler:       _DataStructureService_Propose_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "Commit",
			Handler:       _DataStructureService_Commit_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Error",
			Handler:       _DataStructureService_Error_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ProvideSnapshot",
			Handler:       _DataStructureService_ProvideSnapshot_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "pb/copycat.proto",
}

// Client API for RaftTransportService service

type RaftTransportServiceClient interface {
	Send(ctx context.Context, opts ...grpc.CallOption) (RaftTransportService_SendClient, error)
}

type raftTransportServiceClient struct {
	cc *grpc.ClientConn
}

func NewRaftTransportServiceClient(cc *grpc.ClientConn) RaftTransportServiceClient {
	return &raftTransportServiceClient{cc}
}

func (c *raftTransportServiceClient) Send(ctx context.Context, opts ...grpc.CallOption) (RaftTransportService_SendClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_RaftTransportService_serviceDesc.Streams[0], c.cc, "/pb.RaftTransportService/Send", opts...)
	if err != nil {
		return nil, err
	}
	x := &raftTransportServiceSendClient{stream}
	return x, nil
}

type RaftTransportService_SendClient interface {
	Send(*SendReq) error
	Recv() (*SendResp, error)
	grpc.ClientStream
}

type raftTransportServiceSendClient struct {
	grpc.ClientStream
}

func (x *raftTransportServiceSendClient) Send(m *SendReq) error {
	return x.ClientStream.SendMsg(m)
}

func (x *raftTransportServiceSendClient) Recv() (*SendResp, error) {
	m := new(SendResp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for RaftTransportService service

type RaftTransportServiceServer interface {
	Send(RaftTransportService_SendServer) error
}

func RegisterRaftTransportServiceServer(s *grpc.Server, srv RaftTransportServiceServer) {
	s.RegisterService(&_RaftTransportService_serviceDesc, srv)
}

func _RaftTransportService_Send_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RaftTransportServiceServer).Send(&raftTransportServiceSendServer{stream})
}

type RaftTransportService_SendServer interface {
	Send(*SendResp) error
	Recv() (*SendReq, error)
	grpc.ServerStream
}

type raftTransportServiceSendServer struct {
	grpc.ServerStream
}

func (x *raftTransportServiceSendServer) Send(m *SendResp) error {
	return x.ServerStream.SendMsg(m)
}

func (x *raftTransportServiceSendServer) Recv() (*SendReq, error) {
	m := new(SendReq)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _RaftTransportService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.RaftTransportService",
	HandlerType: (*RaftTransportServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Send",
			Handler:       _RaftTransportService_Send_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "pb/copycat.proto",
}

// Client API for CopyCatService service

type CopyCatServiceClient interface {
	NewDataStructure(ctx context.Context, in *NewDataStructureRequest, opts ...grpc.CallOption) (*NewDataStructureResponse, error)
	StartRaft(ctx context.Context, in *StartRaftRequest, opts ...grpc.CallOption) (*StartRaftResponse, error)
	StopRaft(ctx context.Context, in *StopRaftRequest, opts ...grpc.CallOption) (*StopRaftResponse, error)
}

type copyCatServiceClient struct {
	cc *grpc.ClientConn
}

func NewCopyCatServiceClient(cc *grpc.ClientConn) CopyCatServiceClient {
	return &copyCatServiceClient{cc}
}

func (c *copyCatServiceClient) NewDataStructure(ctx context.Context, in *NewDataStructureRequest, opts ...grpc.CallOption) (*NewDataStructureResponse, error) {
	out := new(NewDataStructureResponse)
	err := grpc.Invoke(ctx, "/pb.CopyCatService/NewDataStructure", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *copyCatServiceClient) StartRaft(ctx context.Context, in *StartRaftRequest, opts ...grpc.CallOption) (*StartRaftResponse, error) {
	out := new(StartRaftResponse)
	err := grpc.Invoke(ctx, "/pb.CopyCatService/StartRaft", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *copyCatServiceClient) StopRaft(ctx context.Context, in *StopRaftRequest, opts ...grpc.CallOption) (*StopRaftResponse, error) {
	out := new(StopRaftResponse)
	err := grpc.Invoke(ctx, "/pb.CopyCatService/StopRaft", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for CopyCatService service

type CopyCatServiceServer interface {
	NewDataStructure(context.Context, *NewDataStructureRequest) (*NewDataStructureResponse, error)
	StartRaft(context.Context, *StartRaftRequest) (*StartRaftResponse, error)
	StopRaft(context.Context, *StopRaftRequest) (*StopRaftResponse, error)
}

func RegisterCopyCatServiceServer(s *grpc.Server, srv CopyCatServiceServer) {
	s.RegisterService(&_CopyCatService_serviceDesc, srv)
}

func _CopyCatService_NewDataStructure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewDataStructureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CopyCatServiceServer).NewDataStructure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.CopyCatService/NewDataStructure",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CopyCatServiceServer).NewDataStructure(ctx, req.(*NewDataStructureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CopyCatService_StartRaft_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartRaftRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CopyCatServiceServer).StartRaft(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.CopyCatService/StartRaft",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CopyCatServiceServer).StartRaft(ctx, req.(*StartRaftRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CopyCatService_StopRaft_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopRaftRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CopyCatServiceServer).StopRaft(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.CopyCatService/StopRaft",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CopyCatServiceServer).StopRaft(ctx, req.(*StopRaftRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _CopyCatService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.CopyCatService",
	HandlerType: (*CopyCatServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "NewDataStructure",
			Handler:    _CopyCatService_NewDataStructure_Handler,
		},
		{
			MethodName: "StartRaft",
			Handler:    _CopyCatService_StartRaft_Handler,
		},
		{
			MethodName: "StopRaft",
			Handler:    _CopyCatService_StopRaft_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pb/copycat.proto",
}

func (m *TestCat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestCat) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.M) > 0 {
		for k, _ := range m.M {
			dAtA[i] = 0xa
			i++
			v := m.M[k]
			mapSize := 1 + len(k) + sovCopycat(uint64(len(k))) + 1 + len(v) + sovCopycat(uint64(len(v)))
			i = encodeVarintCopycat(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintCopycat(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintCopycat(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *RaftIdQueryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftIdQueryRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RaftId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCopycat(dAtA, i, uint64(m.RaftId))
	}
	return i, nil
}

func (m *RaftIdQueryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftIdQueryResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RaftId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCopycat(dAtA, i, uint64(m.RaftId))
	}
	if len(m.Address) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCopycat(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	return i, nil
}

func (m *DataStructureIdRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataStructureIdRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DataStructureId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCopycat(dAtA, i, uint64(m.DataStructureId))
	}
	return i, nil
}

func (m *DataStructureIdResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataStructureIdResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DataStructureId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCopycat(dAtA, i, uint64(m.DataStructureId))
	}
	if m.RaftId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCopycat(dAtA, i, uint64(m.RaftId))
	}
	if len(m.Address) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCopycat(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	return i, nil
}

func (m *Peer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Peer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCopycat(dAtA, i, uint64(m.Id))
	}
	if len(m.RaftAddress) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCopycat(dAtA, i, uint64(len(m.RaftAddress)))
		i += copy(dAtA[i:], m.RaftAddress)
	}
	return i, nil
}

func (m *HostedItems) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HostedItems) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DataStructureToRaftMapping) > 0 {
		for k, _ := range m.DataStructureToRaftMapping {
			dAtA[i] = 0xa
			i++
			v := m.DataStructureToRaftMapping[k]
			mapSize := 1 + sovCopycat(uint64(k)) + 1 + sovCopycat(uint64(v))
			i = encodeVarintCopycat(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCopycat(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCopycat(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *ProposeReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProposeReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DataStructureId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCopycat(dAtA, i, uint64(m.DataStructureId))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCopycat(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *ProposeResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProposeResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ForwardAddress) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCopycat(dAtA, i, uint64(len(m.ForwardAddress)))
		i += copy(dAtA[i:], m.ForwardAddress)
	}
	return i, nil
}

func (m *CommitReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommitReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DataStructureId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCopycat(dAtA, i, uint64(m.DataStructureId))
	}
	return i, nil
}

func (m *CommitResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommitResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCopycat(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *ErrorReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ErrorReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DataStructureId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCopycat(dAtA, i, uint64(m.DataStructureId))
	}
	return i, nil
}

func (m *ErrorResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ErrorResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Error) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCopycat(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	return i, nil
}

func (m *ConsumeSnapshotReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsumeSnapshotReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DataStructureId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCopycat(dAtA, i, uint64(m.DataStructureId))
	}
	return i, nil
}

func (m *ConsumeSnapshotResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsumeSnapshotResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCopycat(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *ProvideSnapshotReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProvideSnapshotReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DataStructureId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCopycat(dAtA, i, uint64(m.DataStructureId))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCopycat(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *ProvideSnapshotResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProvideSnapshotResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *SendReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Message != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCopycat(dAtA, i, uint64(m.Message.Size()))
		n1, err := m.Message.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *SendResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Error != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCopycat(dAtA, i, uint64(m.Error))
	}
	return i, nil
}

func (m *NewDataStructureRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NewDataStructureRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *NewDataStructureResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NewDataStructureResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DataStructureId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCopycat(dAtA, i, uint64(m.DataStructureId))
	}
	return i, nil
}

func (m *StartRaftRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StartRaftRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *StartRaftResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StartRaftResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RaftId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCopycat(dAtA, i, uint64(m.RaftId))
	}
	if len(m.RaftAddress) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCopycat(dAtA, i, uint64(len(m.RaftAddress)))
		i += copy(dAtA[i:], m.RaftAddress)
	}
	return i, nil
}

func (m *StopRaftRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StopRaftRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RaftId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCopycat(dAtA, i, uint64(m.RaftId))
	}
	return i, nil
}

func (m *StopRaftResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StopRaftResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func encodeVarintCopycat(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *TestCat) Size() (n int) {
	var l int
	_ = l
	if len(m.M) > 0 {
		for k, v := range m.M {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCopycat(uint64(len(k))) + 1 + len(v) + sovCopycat(uint64(len(v)))
			n += mapEntrySize + 1 + sovCopycat(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *RaftIdQueryRequest) Size() (n int) {
	var l int
	_ = l
	if m.RaftId != 0 {
		n += 1 + sovCopycat(uint64(m.RaftId))
	}
	return n
}

func (m *RaftIdQueryResponse) Size() (n int) {
	var l int
	_ = l
	if m.RaftId != 0 {
		n += 1 + sovCopycat(uint64(m.RaftId))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovCopycat(uint64(l))
	}
	return n
}

func (m *DataStructureIdRequest) Size() (n int) {
	var l int
	_ = l
	if m.DataStructureId != 0 {
		n += 1 + sovCopycat(uint64(m.DataStructureId))
	}
	return n
}

func (m *DataStructureIdResponse) Size() (n int) {
	var l int
	_ = l
	if m.DataStructureId != 0 {
		n += 1 + sovCopycat(uint64(m.DataStructureId))
	}
	if m.RaftId != 0 {
		n += 1 + sovCopycat(uint64(m.RaftId))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovCopycat(uint64(l))
	}
	return n
}

func (m *Peer) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCopycat(uint64(m.Id))
	}
	l = len(m.RaftAddress)
	if l > 0 {
		n += 1 + l + sovCopycat(uint64(l))
	}
	return n
}

func (m *HostedItems) Size() (n int) {
	var l int
	_ = l
	if len(m.DataStructureToRaftMapping) > 0 {
		for k, v := range m.DataStructureToRaftMapping {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCopycat(uint64(k)) + 1 + sovCopycat(uint64(v))
			n += mapEntrySize + 1 + sovCopycat(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ProposeReq) Size() (n int) {
	var l int
	_ = l
	if m.DataStructureId != 0 {
		n += 1 + sovCopycat(uint64(m.DataStructureId))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovCopycat(uint64(l))
	}
	return n
}

func (m *ProposeResp) Size() (n int) {
	var l int
	_ = l
	l = len(m.ForwardAddress)
	if l > 0 {
		n += 1 + l + sovCopycat(uint64(l))
	}
	return n
}

func (m *CommitReq) Size() (n int) {
	var l int
	_ = l
	if m.DataStructureId != 0 {
		n += 1 + sovCopycat(uint64(m.DataStructureId))
	}
	return n
}

func (m *CommitResp) Size() (n int) {
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovCopycat(uint64(l))
	}
	return n
}

func (m *ErrorReq) Size() (n int) {
	var l int
	_ = l
	if m.DataStructureId != 0 {
		n += 1 + sovCopycat(uint64(m.DataStructureId))
	}
	return n
}

func (m *ErrorResp) Size() (n int) {
	var l int
	_ = l
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovCopycat(uint64(l))
	}
	return n
}

func (m *ConsumeSnapshotReq) Size() (n int) {
	var l int
	_ = l
	if m.DataStructureId != 0 {
		n += 1 + sovCopycat(uint64(m.DataStructureId))
	}
	return n
}

func (m *ConsumeSnapshotResp) Size() (n int) {
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovCopycat(uint64(l))
	}
	return n
}

func (m *ProvideSnapshotReq) Size() (n int) {
	var l int
	_ = l
	if m.DataStructureId != 0 {
		n += 1 + sovCopycat(uint64(m.DataStructureId))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovCopycat(uint64(l))
	}
	return n
}

func (m *ProvideSnapshotResp) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *SendReq) Size() (n int) {
	var l int
	_ = l
	if m.Message != nil {
		l = m.Message.Size()
		n += 1 + l + sovCopycat(uint64(l))
	}
	return n
}

func (m *SendResp) Size() (n int) {
	var l int
	_ = l
	if m.Error != 0 {
		n += 1 + sovCopycat(uint64(m.Error))
	}
	return n
}

func (m *NewDataStructureRequest) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *NewDataStructureResponse) Size() (n int) {
	var l int
	_ = l
	if m.DataStructureId != 0 {
		n += 1 + sovCopycat(uint64(m.DataStructureId))
	}
	return n
}

func (m *StartRaftRequest) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *StartRaftResponse) Size() (n int) {
	var l int
	_ = l
	if m.RaftId != 0 {
		n += 1 + sovCopycat(uint64(m.RaftId))
	}
	l = len(m.RaftAddress)
	if l > 0 {
		n += 1 + l + sovCopycat(uint64(l))
	}
	return n
}

func (m *StopRaftRequest) Size() (n int) {
	var l int
	_ = l
	if m.RaftId != 0 {
		n += 1 + sovCopycat(uint64(m.RaftId))
	}
	return n
}

func (m *StopRaftResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func sovCopycat(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCopycat(x uint64) (n int) {
	return sovCopycat(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TestCat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCopycat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestCat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestCat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field M", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopycat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCopycat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.M == nil {
				m.M = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCopycat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCopycat
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCopycat
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCopycat
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthCopycat
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCopycat(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCopycat
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.M[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCopycat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCopycat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftIdQueryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCopycat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftIdQueryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftIdQueryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftId", wireType)
			}
			m.RaftId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopycat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RaftId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCopycat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCopycat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftIdQueryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCopycat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftIdQueryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftIdQueryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftId", wireType)
			}
			m.RaftId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopycat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RaftId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopycat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCopycat
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCopycat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCopycat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataStructureIdRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCopycat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataStructureIdRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataStructureIdRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataStructureId", wireType)
			}
			m.DataStructureId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopycat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataStructureId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCopycat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCopycat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataStructureIdResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCopycat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataStructureIdResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataStructureIdResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataStructureId", wireType)
			}
			m.DataStructureId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopycat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataStructureId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftId", wireType)
			}
			m.RaftId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopycat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RaftId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopycat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCopycat
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCopycat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCopycat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Peer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCopycat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Peer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Peer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopycat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopycat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCopycat
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RaftAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCopycat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCopycat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HostedItems) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCopycat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HostedItems: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HostedItems: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataStructureToRaftMapping", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopycat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCopycat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DataStructureToRaftMapping == nil {
				m.DataStructureToRaftMapping = make(map[uint64]uint64)
			}
			var mapkey uint64
			var mapvalue uint64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCopycat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCopycat
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCopycat
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCopycat(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCopycat
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DataStructureToRaftMapping[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCopycat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCopycat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProposeReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCopycat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProposeReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProposeReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataStructureId", wireType)
			}
			m.DataStructureId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopycat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataStructureId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopycat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCopycat
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCopycat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCopycat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProposeResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCopycat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProposeResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProposeResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwardAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopycat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCopycat
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForwardAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCopycat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCopycat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommitReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCopycat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataStructureId", wireType)
			}
			m.DataStructureId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopycat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataStructureId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCopycat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCopycat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommitResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCopycat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopycat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCopycat
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCopycat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCopycat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ErrorReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCopycat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ErrorReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ErrorReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataStructureId", wireType)
			}
			m.DataStructureId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopycat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataStructureId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCopycat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCopycat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ErrorResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCopycat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ErrorResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ErrorResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopycat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCopycat
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCopycat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCopycat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsumeSnapshotReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCopycat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsumeSnapshotReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsumeSnapshotReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataStructureId", wireType)
			}
			m.DataStructureId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopycat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataStructureId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCopycat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCopycat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsumeSnapshotResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCopycat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsumeSnapshotResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsumeSnapshotResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopycat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCopycat
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCopycat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCopycat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProvideSnapshotReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCopycat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProvideSnapshotReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProvideSnapshotReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataStructureId", wireType)
			}
			m.DataStructureId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopycat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataStructureId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopycat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCopycat
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCopycat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCopycat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProvideSnapshotResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCopycat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProvideSnapshotResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProvideSnapshotResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCopycat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCopycat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCopycat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopycat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCopycat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Message == nil {
				m.Message = &raftpb.Message{}
			}
			if err := m.Message.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCopycat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCopycat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCopycat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			m.Error = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopycat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Error |= (TransportError(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCopycat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCopycat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NewDataStructureRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCopycat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewDataStructureRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewDataStructureRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCopycat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCopycat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NewDataStructureResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCopycat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewDataStructureResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewDataStructureResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataStructureId", wireType)
			}
			m.DataStructureId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopycat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataStructureId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCopycat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCopycat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StartRaftRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCopycat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartRaftRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartRaftRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCopycat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCopycat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StartRaftResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCopycat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartRaftResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartRaftResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftId", wireType)
			}
			m.RaftId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopycat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RaftId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopycat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCopycat
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RaftAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCopycat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCopycat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StopRaftRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCopycat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StopRaftRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StopRaftRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftId", wireType)
			}
			m.RaftId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopycat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RaftId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCopycat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCopycat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StopRaftResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCopycat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StopRaftResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StopRaftResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCopycat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCopycat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCopycat(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCopycat
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCopycat
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCopycat
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthCopycat
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCopycat
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCopycat(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCopycat = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCopycat   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("pb/copycat.proto", fileDescriptorCopycat) }

var fileDescriptorCopycat = []byte{
	// 861 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x56, 0xdd, 0x72, 0xdb, 0x44,
	0x14, 0xf6, 0x3a, 0x26, 0x6e, 0x8e, 0x53, 0xdb, 0x9c, 0xb8, 0x89, 0x11, 0x60, 0x8c, 0x2e, 0xc0,
	0x29, 0x20, 0x77, 0x42, 0x3a, 0x74, 0x3a, 0x03, 0x0c, 0x75, 0x4a, 0x1b, 0x66, 0x1c, 0x82, 0xdc,
	0x17, 0x90, 0xad, 0xad, 0xeb, 0x01, 0x7b, 0xb7, 0xbb, 0xab, 0x74, 0xfc, 0x50, 0xbc, 0x47, 0x6f,
	0x98, 0xe9, 0x15, 0xd7, 0x34, 0x4f, 0xc2, 0xac, 0x76, 0xa5, 0x4a, 0xb2, 0x4d, 0x70, 0x6f, 0x92,
	0x3d, 0x3f, 0xdf, 0xb7, 0x47, 0x67, 0xbf, 0x73, 0xc6, 0xd0, 0xe4, 0xe3, 0xfe, 0x84, 0xf1, 0xe5,
	0x24, 0x50, 0x1e, 0x17, 0x4c, 0x31, 0x2c, 0xf3, 0xb1, 0xd3, 0x9a, 0xb2, 0x29, 0x8b, 0xcd, 0xbe,
	0x3e, 0x99, 0x88, 0xf3, 0xcd, 0x74, 0xa6, 0x5e, 0x44, 0x63, 0x6f, 0xc2, 0xe6, 0xfd, 0x09, 0x13,
	0x94, 0xc9, 0x3e, 0x55, 0x93, 0xb0, 0x2f, 0x82, 0xe7, 0x2a, 0xfe, 0xc3, 0xc7, 0xf1, 0x3f, 0x93,
	0xee, 0x06, 0x50, 0x7d, 0x46, 0xa5, 0x1a, 0x04, 0x0a, 0xbb, 0x40, 0xe6, 0x6d, 0xd2, 0xdd, 0xe9,
	0xd5, 0x4e, 0xd0, 0xe3, 0x63, 0xcf, 0xfa, 0xbd, 0xe1, 0xe3, 0x85, 0x12, 0x4b, 0x9f, 0xcc, 0x9d,
	0x53, 0xd8, 0x35, 0x06, 0x36, 0x61, 0xe7, 0x77, 0xba, 0x6c, 0x93, 0x2e, 0xe9, 0xed, 0xf9, 0xfa,
	0x88, 0x2d, 0xf8, 0xe0, 0x2a, 0xf8, 0x23, 0xa2, 0xed, 0x72, 0xec, 0x33, 0xc6, 0xc3, 0xf2, 0x03,
	0xe2, 0x7e, 0x0d, 0xe8, 0x07, 0xcf, 0xd5, 0x79, 0xf8, 0x5b, 0x44, 0xc5, 0xd2, 0xa7, 0x2f, 0x23,
	0x2a, 0x15, 0x1e, 0xc2, 0xae, 0xf1, 0xc6, 0x24, 0x15, 0xdf, 0x5a, 0xee, 0x13, 0x38, 0xc8, 0x65,
	0x4b, 0xce, 0x16, 0x92, 0x6e, 0x4a, 0xc7, 0x36, 0x54, 0x7f, 0x0a, 0x43, 0x41, 0xa5, 0xb4, 0x17,
	0x27, 0xa6, 0xfb, 0x08, 0x0e, 0xcf, 0x02, 0x15, 0x8c, 0x94, 0x88, 0x26, 0x2a, 0x12, 0xf4, 0x3c,
	0x4c, 0xae, 0xee, 0x41, 0xa3, 0x10, 0xb1, 0xa4, 0x45, 0xb7, 0x1b, 0xc1, 0xd1, 0x0a, 0x87, 0x2d,
	0xe8, 0x7f, 0x93, 0x64, 0x4a, 0x2f, 0x6f, 0x2a, 0x7d, 0x27, 0x5f, 0xfa, 0x03, 0xa8, 0x5c, 0x52,
	0x2a, 0xb0, 0x0e, 0xe5, 0x94, 0xb6, 0x7c, 0x1e, 0x62, 0x17, 0x6a, 0x1a, 0x9b, 0xff, 0xe0, 0xac,
	0xcb, 0xfd, 0x8b, 0x40, 0xed, 0x29, 0x93, 0x8a, 0x86, 0xe7, 0x8a, 0xce, 0x25, 0x32, 0x70, 0x72,
	0xe5, 0x3c, 0x63, 0x3a, 0x7b, 0x18, 0x70, 0x3e, 0x5b, 0x4c, 0xed, 0x63, 0xf7, 0xf5, 0x63, 0x67,
	0x40, 0xde, 0x66, 0x84, 0x51, 0xc2, 0x7f, 0x50, 0x3a, 0x43, 0xf8, 0xec, 0x06, 0x78, 0x56, 0x3b,
	0x95, 0x35, 0xda, 0xa9, 0x64, 0xb5, 0xf3, 0x0b, 0xc0, 0xa5, 0x60, 0x9c, 0x49, 0xea, 0xd3, 0x97,
	0x5b, 0xf4, 0x1c, 0xa1, 0xa2, 0x5d, 0x31, 0xe1, 0xbe, 0x1f, 0x9f, 0xdd, 0xfb, 0x50, 0x4b, 0xb9,
	0x24, 0xc7, 0x2f, 0xa0, 0xfe, 0x33, 0x13, 0xaf, 0x02, 0x11, 0x26, 0xfd, 0x34, 0x6a, 0x2e, 0x78,
	0xdd, 0xfb, 0xb0, 0x37, 0x60, 0xf3, 0xf9, 0x4c, 0x6d, 0x55, 0x81, 0xdb, 0x05, 0x48, 0x60, 0x92,
	0xa7, 0xf5, 0x90, 0x4c, 0x3d, 0xa7, 0x70, 0xeb, 0xb1, 0x10, 0x4c, 0x6c, 0xc7, 0xfb, 0x39, 0xec,
	0x59, 0x94, 0xe4, 0xba, 0x71, 0xb1, 0x61, 0x4b, 0x37, 0x86, 0xfb, 0x03, 0xe0, 0x80, 0x2d, 0x64,
	0x34, 0xa7, 0xa3, 0x45, 0xc0, 0xe5, 0x0b, 0xb6, 0x65, 0xe9, 0xc7, 0x70, 0xb0, 0x82, 0xdf, 0xf0,
	0x0d, 0x3e, 0xe0, 0xa5, 0x60, 0x57, 0xb3, 0xf0, 0xfd, 0xae, 0x5a, 0xfb, 0x4e, 0x77, 0xe0, 0x60,
	0x85, 0x53, 0x72, 0xf7, 0x14, 0xaa, 0x23, 0xba, 0xd0, 0x43, 0x8c, 0xc7, 0x50, 0x1d, 0x52, 0x29,
	0x83, 0x29, 0x8d, 0x79, 0x6b, 0x27, 0x0d, 0xcf, 0x6c, 0x36, 0xcf, 0xba, 0xfd, 0x24, 0xae, 0x9b,
	0x6c, 0x50, 0x92, 0x63, 0x2f, 0xdb, 0xad, 0xba, 0x5d, 0x72, 0x22, 0x58, 0x48, 0xce, 0x84, 0x32,
	0x4d, 0xb5, 0x1d, 0xfc, 0x08, 0x8e, 0x2e, 0xe8, 0xab, 0x5c, 0xb1, 0x76, 0x79, 0xb8, 0x67, 0xd0,
	0x5e, 0x0d, 0x6d, 0xbb, 0x13, 0x5c, 0x84, 0xe6, 0x48, 0x05, 0x42, 0xe9, 0xe1, 0x48, 0x98, 0x87,
	0xf0, 0x61, 0xc6, 0x77, 0xc3, 0xde, 0xbb, 0x79, 0x15, 0x1c, 0x43, 0x63, 0xa4, 0x18, 0xcf, 0xdc,
	0xb0, 0x71, 0xe7, 0xc6, 0xd5, 0x24, 0xa9, 0xe6, 0xe2, 0xbb, 0xdf, 0x43, 0xf3, 0x09, 0x93, 0x72,
	0xc6, 0xe3, 0x3d, 0x7c, 0x11, 0xcc, 0xa9, 0xc4, 0x86, 0xb9, 0xd4, 0xee, 0xe6, 0x66, 0x09, 0xdb,
	0xd0, 0x2a, 0x7c, 0x99, 0x89, 0x90, 0xbb, 0x9f, 0x42, 0x3d, 0xdf, 0x5a, 0xac, 0x41, 0xf5, 0x82,
	0xc5, 0xc7, 0x66, 0xe9, 0xe4, 0xcf, 0x72, 0x01, 0x39, 0xa2, 0xe2, 0x6a, 0x36, 0xa1, 0xe8, 0x41,
	0xd5, 0x0e, 0x29, 0xd6, 0xf5, 0xfb, 0xbc, 0x9b, 0x7e, 0xa7, 0x91, 0xb3, 0x25, 0x77, 0x4b, 0x3d,
	0x82, 0x5f, 0xc1, 0xae, 0x19, 0x33, 0xbc, 0xad, 0xc3, 0xe9, 0xa4, 0x3a, 0xf5, 0xac, 0xa9, 0x93,
	0xef, 0x91, 0x54, 0x00, 0xb8, 0xaf, 0x83, 0xc9, 0xf0, 0x39, 0xb7, 0x33, 0x96, 0xcd, 0x3c, 0x83,
	0x46, 0x61, 0x04, 0xf0, 0xd0, 0x10, 0x16, 0xe7, 0xca, 0x39, 0x5a, 0xeb, 0xd7, 0x3c, 0xf8, 0x14,
	0x1a, 0x05, 0x25, 0x1b, 0x96, 0xd5, 0x91, 0x31, 0x2c, 0xeb, 0x64, 0x5f, 0xea, 0x91, 0x7b, 0xe4,
	0xe4, 0x47, 0x68, 0xe9, 0xce, 0xa7, 0x2d, 0x4d, 0xda, 0xf5, 0x25, 0x54, 0xb4, 0xbc, 0xb1, 0xa6,
	0xe1, 0x76, 0x3c, 0x9c, 0xfd, 0x77, 0x46, 0x4a, 0xf0, 0x37, 0x81, 0xfa, 0x80, 0xf1, 0xe5, 0x20,
	0x48, 0xb1, 0xbf, 0x42, 0xb3, 0xa8, 0x64, 0xfc, 0x58, 0x43, 0x37, 0x48, 0xdf, 0xf9, 0x64, 0x7d,
	0xd0, 0x08, 0xc6, 0x2d, 0xe1, 0x43, 0xd8, 0x4b, 0x05, 0x8c, 0xad, 0xb8, 0x88, 0x82, 0xc6, 0x9d,
	0x3b, 0x05, 0x6f, 0x8a, 0xfd, 0x0e, 0x6e, 0x25, 0x12, 0xc4, 0x03, 0x93, 0x94, 0xd3, 0xae, 0xd3,
	0xca, 0x3b, 0x13, 0xe0, 0xa3, 0xd6, 0xeb, 0xb7, 0x9d, 0xd2, 0x9b, 0xb7, 0x9d, 0xd2, 0xeb, 0xeb,
	0x0e, 0x79, 0x73, 0xdd, 0x21, 0xff, 0x5c, 0x77, 0xc8, 0x78, 0x37, 0xfe, 0x75, 0xf3, 0xed, 0xbf,
	0x01, 0x00, 0x00, 0xff, 0xff, 0xa3, 0xe5, 0xba, 0x0e, 0x3a, 0x09, 0x00, 0x00,
}
